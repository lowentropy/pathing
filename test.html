<html>
<head>
<style>
  canvas {
    border: 1px solid black;
  }
</style>
</head>
<body>
  <canvas id='the-canvas' width="500" height="500"></canvas>
  <script type="text/javascript">
    var size = 25;
    var area = 5;
    var fudge = 1.1;

    var canvas = document.getElementById('the-canvas');
    var ctx = canvas.getContext('2d');

    var wedge = Math.PI / 3;
    var cos = 0.5;
    var sin = Math.sqrt(3) / 2;

    var height = size * 2;
    var width = height * sin;

    var center = { q: 0, r: 0 };
    var start, end;

    var cells = {};

    function addCell(qr, filled) {
      cells[qr.q] = cells[qr.q] || {};
      cells[qr.q][qr.r] = { qr: qr, filled: filled };
    }

    function getCell(qr) {
      var row = cells[qr.q];
      if (row) return row[qr.r];
      return null;
    }

    function axialToPixels(qr) {
      return {
        x: width * (qr.q + qr.r / 2) + canvas.width/2,
        y: width * qr.r * sin + canvas.height/2 };
    }

    function pixelsToAxial(xy) {
      var x = xy.x - canvas.width/2,
          y = xy.y - canvas.height/2;
      var r = y / (width * sin);
      var q = x / width - r / 2;
      return { q: Math.round(q), r: Math.round(r) };
    }

    function axialToCube(qr) {
      return { x: qr.q, y: qr.r, z: -qr.q-qr.r };
    }

    function axialDistance(a, b) {
      var q = a.q - b.q, r = a.r - b.r;
      return (Math.abs(q) + Math.abs(r) + Math.abs(q + r)) / 2;
    }

    function drawCell(qr, shaded, color) {
      if (!color) color = '#cccccc';
      ctx.strokeStyle = color;
      ctx.fillStyle = color;
      ctx.lineWidth = 1;

      var c = axialToPixels(qr);

      ctx.beginPath();

      for (var i = 0; i <= 6; i++) {
        var angle = wedge * (i + 0.5);
        var xy = {
          x: c.x + size * Math.cos(angle),
          y: c.y + size * Math.sin(angle) };
        if (i == 0) {
          ctx.moveTo(xy.x, xy.y);
        } else {
          ctx.lineTo(xy.x, xy.y);
          ctx.stroke();
        }
      }

      ctx.closePath();

      if (shaded) ctx.fill();
    }


    function drawEdge(qr, e, color) {
      var xy = axialToPixels(qr),
           x = xy.x + canvas.width/2,
           y = xy.y + canvas.height/2,
           a1 = wedge * (e - 0.5),
           a2 = wedge * (e + 0.5);
      if (!color) color = 'blue';
      ctx.strokeStyle = color;
      ctx.lineWidth = 5;
      ctx.beginPath()
      ctx.moveTo(x + size * Math.cos(a1), y - size * Math.sin(a1));
      ctx.lineTo(x + size * Math.cos(a2), y - size * Math.sin(a2));
      ctx.closePath();
      ctx.stroke();
    }

    function sign(x) {
      if (x < 0)
        return -1;
      else
        return 1;
    }

    var dirs = [
      [[+0, -1, 2], null, [-1, +1, 4]],
      [[-1, +0, 3], null, [+1, +0, 0]],
      [[+1, -1, 1], null, [+0, +1, 5]]
    ];

    var edge_offsets = [
      [+1, +0], [+1, -1], [+0, -1], [-1, +0], [-1, +1], [+0, +1]
    ];

    function lineOfSight(a, b) {
      var dy = b.r - a.r,
         dx2 = 2 * (b.q - a.q) + dy,
          ty = Math.abs(dy),
          tx = Math.abs(dx2),
         tx3 = tx + tx + tx,
         ty3 = ty + ty + ty,
           n = a,
          xs = sign(dx2),
          ys = sign(dy),
           e = -tx-tx,
           d = null,
           le = e;
      while (true) {
        if (n.q == b.q && n.r == b.r) return true;
        var c = getCell(n);
        if (c.filled) return false;
        if (e >= 0) {
          d = dirs[-xs+1][ys+1];    // UP LEFT
          e = e - tx3 - ty3;
        } else {
          e = e + ty3;
          if (e > -tx) {
            d = dirs[xs+1][ys+1];   // UP RIGHT
            e = e - tx3;
          } else if (e < -tx3) {
            d = dirs[xs+1][-ys+1];  // DOWN RIGHT
            e = e + tx3;
          } else {
            d = dirs[1][xs+1];      // RIGHT
            e = e + ty3;
          }
        }
        // if the nearest neighbor to the edge crossed
        // by this transition is filled, then fail
        var sum = le + e + tx + tx + tx + tx;
        var danger_edge = (d[2] + 6 - sign(sum) * xs * ys) % 6;
        var danger = { q: n.q + edge_offsets[danger_edge][0], r: n.r + edge_offsets[danger_edge][1] };
        console.log('n.q:', n.q, 'n.r:', n.r, 'e:', d[2], 'sum:', sum, 'de:', danger_edge, 'd.q:', danger.q, 'd.r:', danger.r) // XXX
        danger = getCell(danger);
        if (sum != 0 && tx != 0 && danger && danger.filled) return false;
        le = e;
        c.maybe_clean = (sum == 0);
        console.log('CLEAN (los):', n.q, n.r, c.clean); // XXX
        c.maybe_edge = d[2];
        n = { q: n.q + d[0], r: n.r + d[1] };
      }
    }

    function drawLine(a, b) {
      var dy = b.r - a.r,
         dx2 = 2 * (b.q - a.q) + dy,
          ty = Math.abs(dy),
          tx = Math.abs(dx2),
         tx3 = tx + tx + tx,
         ty3 = ty + ty + ty,
           n = a,
          xs = sign(dx2),
          ys = sign(dy),
           e = -tx-tx,
           i = 0,
           d = null,
          le = e;
      while (true) {
        drawCell(n, false, 'blue');
        if (n.q == b.q && n.r == b.r) break;
        if (e >= 0) {
          d = dirs[-xs+1][ys+1];
          e = e - tx3 - ty3;
        } else {
          e = e + ty3;
          if (e > -tx) {
            d = dirs[xs+1][ys+1];
            e = e - tx3;
          } else if (e < -tx3) {
            d = dirs[xs+1][-ys+1];
            e = e + tx3;
          } else {
            d = dirs[1][xs+1];
            e = e + ty3;
          }
        }

        // get the danger cell
        var sum = le + e + tx + tx + tx + tx;
        var danger_edge = (d[2] + 6 - sign(sum) * xs * ys) % 6;
        var danger = { q: n.q + edge_offsets[danger_edge][0], r: n.r + edge_offsets[danger_edge][1] };

        // console.log(le+tx+tx, e+tx+tx);

        // draw a line from the edge midpoint to the danger cell
        if (sum != 0) {
          var m = midpoint(n, d[2]),
              xy1 = axialToPixels(m),
              xy2 = axialToPixels(danger);
          ctx.strokeStyle = 'green';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(xy1.x, xy1.y);
          ctx.lineTo(xy2.x, xy2.y);
          ctx.closePath();
          ctx.stroke();
        }

        le = e;
        n = { q: n.q + d[0], r: n.r + d[1] };
      }
      var xy1 = axialToPixels(a),
          xy2 = axialToPixels(b);
      ctx.lineWidth = 3;
      ctx.strokeStyle = 'red';
      ctx.beginPath()
      ctx.moveTo(xy1.x, xy1.y);
      ctx.lineTo(xy2.x, xy2.y);
      ctx.closePath();
      ctx.stroke();
    }

    function cost(a, b) {
      var a = axialToPixels(a),
          b = axialToPixels(b),
          x = a.x - b.x,
          y = a.y - b.y;
      return Math.sqrt(x * x + y * y);
    }

    function setVertex(c) {
      var los = lineOfSight(c.qr, c.parent.qr)
      if (los) {
        c.los = true;
        c.edge = c.maybe_edge;
        c.clean = c.maybe_clean;
        return;
      } else {
        c.los = false;
        console.log('CLEAN (set):', c.qr.q, c.qr.r, true); // XXX
        c.clean = true;
      }
      var min = Infinity, t = null, ii = null;
      eachNeighbor(c.qr, function(qr, i) {
        var n = getCell(qr);
        if (n && n.closed) {
          var cc = n.g + cost(n.qr, c.qr);
          if (cc < min) {
            min = cc;
            t = n;
            ii = i;
          }
        }
      });
      c.edge = ii;
      c.parent = t;
      c.g = min;
    }

    function update(c, n, open) {
      var cc = c.parent.g + cost(c.parent.qr, n.qr);
      if (cc < n.g) {
        n.parent = c.parent;
        n.g = cc;
        n.h = heuristic(n);
        if (!n.open) {
          n.open = true;
          open.push(n);
        }
      }
    }

    function heuristic(c) {
      return cost(c.qr, end) * fudge;
    }

    function drawCircle(qr) {
      var xy = axialToPixels(qr);
      ctx.fillStyle = 'blue';
      ctx.beginPath();
      ctx.arc(xy.x, xy.y, 5, 0, Math.PI*2);
      ctx.closePath();
      ctx.fill();
    }

    function drawPath(path, color) {
      var xo, yo;
      for (var i = 0; i < path.length; i++) {
        var xy = axialToPixels(path[i]);
        if (i > 0) {
          ctx.lineWidth = 3;
          ctx.strokeStyle = color;
          ctx.beginPath()
          ctx.moveTo(xo, yo);
          ctx.lineTo(xy.x, xy.y);
          ctx.closePath();
          ctx.stroke();
        }
        xo = xy.x;
        yo = xy.y;
      }
    }

    function findPath() {
      getCell(end).goal = true;
      var c = getCell(start);
      c.g = 0;
      c.h = heuristic(c);
      c.parent = c;
      c.start = true;
      c.open = true;
      var open = [c];
      while (open.length) {
        open.sort(function(a, b) {
          return a.g + a.h - b.g - b.h;
        });
        c = open.shift();
        setVertex(c);
        // drawCircle(c.qr);
        if (c.goal) {
          var path = [c.qr];
          while (c.parent != c) {
            c = c.parent;
            path.unshift(c.qr);
          }
          return path;
        }
        c.closed = true;
        eachNeighbor(c.qr, function(qr) {
          var n = getCell(qr);
          if (n && !n.filled && !n.closed) {
            if (n.g == null) n.g = Infinity;
            update(c, n, open);
          }
        });
      }
      return null;
    }

    function eachNeighbor(qr, f) {
      f({ q: qr.q+1, r: qr.r+0 }, 0);
      f({ q: qr.q-1, r: qr.r+0 }, 3);
      f({ q: qr.q+0, r: qr.r+1 }, 5);
      f({ q: qr.q+0, r: qr.r-1 }, 2);
      f({ q: qr.q+1, r: qr.r-1 }, 1);
      f({ q: qr.q-1, r: qr.r+1 }, 4);
    }

    function chooseOpenCell() {
      var q = parseInt(Math.random() * (area * 2 + 1)) - area,
          r = parseInt(Math.random() * (area * 2 + 1)) - area,
          qr = { q: q, r: r },
          d = axialDistance(center, qr);
      if ((d > area) || getCell(qr).filled)
        return chooseOpenCell()
      return qr;
    }

    function main() {
      for (var q = -area; q <= area; q++) {
        for (var r = -area; r <= area; r++) {
          if (q+r >= -area && q+r <= area) {
            var qr = { q: q, r: r };
            var filled = Math.random() < 0.3;
            addCell(qr, filled);
            drawCell(qr, filled);
          }
        }
      }
      clicked(axialToPixels(chooseOpenCell()));
      clicked(axialToPixels(chooseOpenCell()));
    }

    function clicked(xy) {
      var qr = pixelsToAxial(xy);
      var d = axialDistance(center, qr);
      if (end || (d > area) || getCell(qr).filled) {
        return;
      }
      drawCell(qr, false, 'red');
      if (start) {
        end = qr;
        // drawLine(start, end);
        var path = findPath();
        if (path) {
          // drawPath(path, 'red')
          path = fixPath(path);
          drawPath(path, 'blue');
        }
      } else {
        start = qr;
      }
    }

    var midpoints = [
      [0.5, 0],
      [0.5, -0.5],
      [0, -0.5],
      [-0.5, 0],
      [-0.5, 0.5],
      [0, 0.5]
    ];

    function midpoint(qr, e) {
      return { q: qr.q + midpoints[e][0], r: qr.r + midpoints[e][1] };
    }

    function fixPath(path) {
      var fixed = [];
      var last = null, last2 = null;
      for (var i = 0; i < path.length; i++) {
        var c = getCell(path[i]);



        // if (c.parent == c) {
        //   fixed.push(c.qr);
        // } else {
        //   if (last.parent != last) {
        //     fixed.push(midpoint(last.qr, (c.edge+3)%6));
        //   }
        //   if (c.goal) {
        //     fixed.push(c.qr)
        //   } else {
        //     fixed.push(midpoint(c.qr, c.edge));
        //   }
        // }


        if (last && last.clean && c.clean) {
          fixed.pop();
          fixed.push(midpoint(last.qr, last.edge));
          fixed.push(midpoint(last.qr, (c.edge+3)%6));
        }
        fixed.push(c.qr);


        // fixed.push(c.qr);


        // drawCell(c.qr, false, c.start ? 'green' : (c.clean ? 'blue' : 'red')); // XXX
        last2 = last;
        last = c;
      }
      return fixed;
    }

    function relMouseCoords(event) {
      var totalOffsetX = 0;
      var totalOffsetY = 0;
      var canvasX = 0;
      var canvasY = 0;
      var currentElement = this;

      do {
        totalOffsetX += currentElement.offsetLeft - currentElement.scrollLeft;
        totalOffsetY += currentElement.offsetTop - currentElement.scrollTop;
      }
      while(currentElement = currentElement.offsetParent)

      canvasX = event.pageX - totalOffsetX;
      canvasY = event.pageY - totalOffsetY;

      return { x: canvasX, y: canvasY }
    }

    HTMLCanvasElement.prototype.relMouseCoords = relMouseCoords;

    canvas.addEventListener("click", function(event) {
      clicked(canvas.relMouseCoords(event));
    });

    main();

  </script>
</body>
</html>
